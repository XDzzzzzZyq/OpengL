#version 460 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout(rgba16f, binding = 3) uniform image2D U_pos;
layout(r16f,    binding = 4) uniform image2D U_Lighting;
layout(rgba8  , binding = 5) uniform image2D U_alpha;
uniform samplerCube Shadow_Map;

uniform mat4 light_trans;
uniform vec2 U_UV;
uniform float ratio;
uniform vec3 U_offset[16];
uniform int frame;
uniform float light_far;
uniform float update_rate;
uniform float offset;

float evaluateShadow(float c_depth, float min_depth){
	float bias = 0.015;
	float range = 0.005;
	float delta = c_depth - min_depth - bias;  // delta greater/equal than 0

	return 1-smoothstep(0, range, delta);
}

float shadow_at(ivec2 uv, vec3 offset, vec3 light_pos){
	vec3 Pos = imageLoad(U_pos, uv).xyz;
	vec3 L = Pos - light_pos + offset * U_offset[frame%16] * 10;
	float dist = length(L);

	float closestDepth = texture(Shadow_Map, normalize(L)+offset).r; 
	float currentDepth = dist/light_far;
	return evaluateShadow(currentDepth, closestDepth);
}

void main(){

	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	float alpha = imageLoad(U_alpha, uv).r;
		if(alpha < 0.5){
			imageStore(U_Lighting, uv, vec4(1));
			return;
	}
	
	vec3 light_pos = vec3(light_trans*vec4(2 * U_UV * vec2(ratio, 1) - 1, 0, 1));

	float shadow = 0.0;
	float samples = 3.0;
	for(float x = -offset; x < offset; x += offset / (samples * 0.5))
	    for(float y = -offset; y < offset; y += offset / (samples * 0.5))
	        for(float z = -offset; z < offset; z += offset / (samples * 0.5))
	            shadow += shadow_at(uv, vec3(x, y, z), light_pos);

	shadow /= (samples * samples * samples);

	float shadow_b = imageLoad(U_Lighting, uv).r;
	shadow = shadow_b + update_rate * (shadow - shadow_b);

	imageStore(U_Lighting, uv, vec4(vec3(shadow), 1));
}